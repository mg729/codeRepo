# 알고리즘

## 알고리즘 성능 측정
- 시간적 효율성을 우선시함  
- 수행되는 __명령어수__ 가 적을수록 시간적 효율성이 좋음  
- 빅오 표기법  
- 1초 동안 과연 몇 번의 연산을 할 수 있는가?  
- C언어 기준으로 __10의 9승__ 번 명령어가 수행되 면 1초가 걸린다.  

## 완전 탐색 - Brute Force
> 문제 해결을 위해 모든 경우의 수를 탐색   
> ex) 순차탐색, __경우의 수__ 문제  


* __백트래킹__ : 어느 지점에서 더이상 탐색이 필요없다고 판단될 때 탐색을 멈추고 이전 단계로돌아가서 다른 방법을 찾는 방법  

1. 모든 경우의 수를 생성하고 이를 탐색하는 완전탐색 알고리즘  
2. 완전탐색의 시간복잡도를 기준으로 보다 효율적인 알고리즘으로 문제를 해결할 수 있는지 탐색  
3. 다른 알고리즘 사용 불가 시, 완전 탐색의 depth를 설정하거나 백트래킹을 사용하여 불필요한 탐색을 줄임  

* 경우의 수 문제는 __완전 탐색__ 으로 해결 가능  
* 완전 탐색은 __재귀함수__ 로 구현 가능  
    ```cpp
    int recursiveSum(int n)
    {
        if(n == 1) return 1;
        return n + recursiveSum(n-1);
    }
    ```
    * 재귀함수의 조건  
        * __종료부__ : 재귀함수의 끝`if(n == 1) return 1;`  
        * __분할부__ : 재귀함수를 문제사이즈를 줄여서 호출하는 부분`recursiveSum(n-1)`  
        * __해결부__ :  문제를 해결하는 부분 (연산부분)`return n + recursiveSum(n-1);`  
<!--점화식 : An = F(An-1) : n번째항을 나타낼 때 이전항을가지고 n번째항의 값을 구하는관계식-->

* [1 ~ 7 까지의 숫자 카드가 있을 때 , 이것을 나열할 수 있는 경우의 수를 출력하라](0531_1.cpp)  
* [SWEA모의기출 문제 1952.수영장](1952.cpp)  
* [BOJ사다리조작](15684.cpp)  
* [BOJ테트로미노](14500.cpp)  
* [SWEA모의기출 문제_디저트카페]()  
* [SWEA모의기출 문제_보호필름]()  
* [BOJ_치킨배달]()  

